package{	/*	*	Watts Up	*	Document class for Watts Up Interactive	*	*	@author Sarah Grant	*	@since  04.2013	*/		import com.carlcalderon.arthropod.Debug;	import com.dixond.events.CustomEvent;	import com.dixond.ia.AppConfig;	import com.dixond.ia.AttractLoop;	import com.dixond.ia.AttractLoopVideo;	import com.dixond.ia.Cursor;	import com.dixond.ia.FullscreenHack;	import com.dixond.ia.IdleTimeout;	import com.dixond.logging.*;	import com.dixond.net.SerialInterface;	import com.dixond.utils.Textd;	import com.dixond.utils.Util;	import com.greensock.*;	import com.greensock.easing.*;	import com.greensock.events.*;	import com.greensock.loading.*;	import com.greensock.loading.display.*;		import flash.display.DisplayObject;	import flash.display.Graphics;	import flash.display.MovieClip;	import flash.display.Shape;	import flash.display.Sprite;	import flash.display.StageScaleMode;	import flash.events.*;	import flash.media.Sound;    import flash.media.SoundChannel;	import flash.net.URLRequest;	import flash.net.navigateToURL;	import flash.system.Capabilities;	import flash.text.StyleSheet;	import flash.text.TextField;	import flash.text.TextFormat;		import wattsup.MLTextManager;	import wattsup.LevelScreen;	import flash.utils.Timer;		public class WattsUp extends Sprite {		private var _log:Logger;		private var _outputPanelView:OutputPanelView;		private var _arthropodView:ArthropodView;		private var _contentXML:XML;		private var _tm:MLTextManager;		private var _queue:LoaderMax; 		// for loading all media		private var _paths:Object = {image:"media/images/", sound:"media/sounds/"};		private var _images:Object = {}; 	// all images loaded for use in this interactive		private var _sounds:Object = {}; 	// all sounds loaded for use in this interactive		private var _videos:Object = {};	// all flv anims for use in this interactive		private var _attractLoopHolder:Sprite;		private var _attractLoop:AttractLoopVideo;		private var _idleTimer:IdleTimeout;		private var _active:Boolean = false;		private var _levelScreen:LevelScreen;		private var _serial:SerialInterface;		private var _timer:Timer;		private var _debugger:TextField = new TextField();				public function WattsUp() {						initLog(); //make the logging available right away						initApp();						stage.scaleMode = StageScaleMode.NO_SCALE;		}				private function initApp() {			// read any settings data from config file			var configUrl:String = "config.xml";			AppConfig.init(configUrl);			AppConfig.getInstance().addEventListener(Event.COMPLETE, appConfigCompleteHandler, false, 0, true);		}				private function initLog() {						/*this.addChild(_debugger);			var format:TextFormat = new TextFormat();			format.size = 36;			_debugger.background=true;			_debugger.backgroundColor = 0xFFFFFF;			_debugger.setTextFormat(format);			_debugger.x = 40;			_debugger.y = 40;			_debugger.width = 500;			_debugger.height = 800;			_debugger.text = "Debugging started\n";*/			//_debugger.scrollV = _debugger.numLines;						// start off with default to DEBUG. If config file differs, it will overwrite this setting			_log = Logger.getLog();			_log.setLevel(Logger.DEBUG);			_outputPanelView = new OutputPanelView(_log);			_arthropodView = new ArthropodView(_log);						var d:Date = new Date();			var playerType:String = Capabilities.playerType;		}				private function appConfigCompleteHandler(ev:Event) {			// override default setting with config setting			var logLevel = AppConfig.settings.log_level;			_log.setLevel(Logger[logLevel]); 						_timer = new Timer(1000,1);						stage.scaleMode = StageScaleMode.SHOW_ALL;			if (AppConfig.getSetting("fullscreen") == "true"){				var delay = int(AppConfig.getSetting("fullscreen_delay_seconds"));				var fullscreenHack = new FullscreenHack(this.stage, delay);			}						if (AppConfig.getSetting("hide_cursor") == "true") {				Cursor.hide();			}						initSerial();			initLoading();		}				private function initSerial():void {			_log.info("initSerial, connect to ports " + AppConfig.settings.port1 + ".");			_serial = new SerialInterface();			_serial.connect("localhost", AppConfig.settings.port1);			_serial.addEventListener(SerialInterface.SERIAL_DATA, _onSerialData);			_serial.addEventListener(SerialInterface.CONNECT, _onSerialConnect);			_serial.addEventListener(SerialInterface.CONNECT_FAILED, _onSerialConnectFailed);		}				private function _onSerialConnectFailed(ev:CustomEvent):void {			_log.info("serial connect failed.");		}				private function _onSerialConnect(ev:CustomEvent):void {			_log.info("serial connected.");		}				private function _onSerialData(ev:CustomEvent):void {			_log.info("serial data received: " + ev.params.data + "   ");			//_debugger.appendText("serial data received: " + ev.params.data + "\n");			//_debugger.scrollV = _debugger.numLines;						if ( _levelScreen == null ) return;						// every time we have serial data, reset the timer so we don't go into attract loop mode			// this is the only place the attract loop is stopped. on serial data received.			_idleTimer.reset();						// button was let go			if (ev.params.data.indexOf("B 0") > -1) {				// if we are in attract loop mode				if (_active) {					_active = false;					_attractLoop.stop();					// reset the piece					_levelScreen.attractLoop("stop");					_levelScreen.visible = true;				}				else {					//trace("check order");					_levelScreen.checkOrder();				}			}			else if (ev.params.data.indexOf("B 1") > -1) {				return;			}			else {				// if we are in attract loop mode				if (_active) {					_active = false;					_attractLoop.stop();					// reset the piece					_levelScreen.attractLoop("stop");					_levelScreen.visible = true;				}				// object was removed or added (respectively)				if (ev.params.data.indexOf("0000000000") > -1) {					//trace("appliance removed: " + ev.params.data.substring(0,1));					_levelScreen.removeObject(ev.params.data.substring(0,1));				}				else {					//trace("appliance added: " + ev.params.data);					_levelScreen.addObject(ev.params.data);				}			}		}				private function initLoading() {			//_log.info("initLoading");			_queue = new LoaderMax({name:"mainQueue", onProgress:loadQueueProgressHandler, onComplete:loadQueueCompleteHandler, onError:loadQueueErrorHandler});						var contentUrl:String = "wattsup-content.xml";			var contentLoader = new XMLLoader(contentUrl, {onComplete:textLoadCompleteHandler, onError:textLoadErrorHandler, onFail:textLoadFailHandler, autoDispose:true}) 			_queue.append(contentLoader);						var fontUrl = "fonts.swf";			var fontLoader = new SWFLoader(fontUrl, {onComplete:fontsLoadCompleteHandler, onError:fontLoadErrorHandler, onFail:fontLoadErrorHandler});			_queue.append(fontLoader);						_queue.append(new MP3Loader(_paths.sound+"ArpSlot3.mp3", {name:"beep", autoPlay: false, repeat:0, onComplete:soundLoadCompleteHandler, onError:soundLoadErrorHandler}));			_queue.append(new MP3Loader(_paths.sound+"GameWinSound.mp3", {name:"win", autoPlay: false, repeat:0, onComplete:soundLoadCompleteHandler, onError:soundLoadErrorHandler}));			_queue.append(new MP3Loader(_paths.sound+"WattsBuzz1.mp3", {name:"buzz", autoPlay: false, repeat:0, onComplete:soundLoadCompleteHandler, onError:soundLoadErrorHandler}));			_queue.append(new ImageLoader(_paths.image+"gridmask.png", {name:"gridmask", onComplete:imageLoadCompleteHandler, onError:imageLoadErrorHandler}));			_queue.append(new ImageLoader(_paths.image+"greencheck.png", {name:"greencheck", onComplete:imageLoadCompleteHandler, onError:imageLoadErrorHandler}));			_queue.append(new ImageLoader(_paths.image+"redx.png", {name:"redx", onComplete:imageLoadCompleteHandler, onError:imageLoadErrorHandler}));			_queue.load();		}				private function fontsLoadCompleteHandler(ev:LoaderEvent) {			//_log.info("Fonts loaded:\n" + ev.target.rawContent.getFontList());		}				private function fontLoadErrorHandler(ev:LoaderEvent) {			//_log.error("fontLoadErrorHandler()", ev.text);		}				private function textLoadCompleteHandler(ev:LoaderEvent) {			//_log.info("text load complete success");			_contentXML = ev.target.content as XML;			_videos = _contentXML.flv_anims;						textSetup();		}				private function textLoadErrorHandler(ev:LoaderEvent) {			//_log.debug("textLoadErrorHandler()", ev.text);		}				private function textLoadFailHandler(ev:LoaderEvent) {			//_log.debug("textLoadFailHandler()", ev.text);		}				private function imageLoadCompleteHandler(ev:LoaderEvent):void {			//_log.debug("image load complete success");			var loader = ev.target;			var loaderName = loader.name;			// adds the actual Bitmap data of the image via rawContent 			_images[loaderName] = loader.rawContent;		}				private function imageLoadErrorHandler(ev:LoaderEvent):void {			//_log.debug("imageLoadErrorHandler()", ev.text);		}				private function soundLoadCompleteHandler(ev:LoaderEvent):void {			//_log.debug("sound load complete success");			var loader = ev.target;			var loaderName = loader.name;			// adds the sprite container containing the sound. 			_sounds[loaderName] = loader.content;			//_log.debug(loader.name + " sound load complete success");		}				private function soundLoadErrorHandler(ev:LoaderEvent):void {			//_log.debug("soundLoadErrorHandler()", ev.text);		}				private function loadQueueProgressHandler(ev:LoaderEvent):void {			//var q = ev.target;			//_log.debug("Watts Up\n\nLoading: " + int(q.progress * 100) + "%");		}				private function loadQueueCompleteHandler(ev:LoaderEvent):void {			//_log.debug("loadQueueCompleteHandler()", "Media is loaded!");			appSetup();		}				private function loadQueueErrorHandler(ev:LoaderEvent):void {			//_log.error("Could not load " + ev.target + ": " + ev.text);		}				private function textSetup() {			//_log.info("text setup");			// make the textManager and such here			_tm = MLTextManager.init(_contentXML, "english", "blueReg");			//_tm.setUseEmbeddedFonts(true);						// Note: could also load an external stylesheet file and assign it directly via _tm.setStyleSheet()			// But for now were creating them all internally here and assigning them via _tm.addStyle.						var colors = {blue:"#002b5c", green:"#00a651", red:"#ED1C24"};						//HelveticaMed not working on PC?			var blueReg = {fontFamily: "Helvetica", fontSize:"40", color:colors.blue, textAlign:"center"};			var greenMed = {fontFamily: "Helvetica", fontSize:"40", color:colors.green, textAlign:"center"};			var redMed = {fontFamily: "Helvetica", fontSize:"40", color:colors.red, textAlign:"center"};						_tm.addStyle(".blueReg", blueReg);			_tm.addStyle(".greenMed", greenMed);			_tm.addStyle(".redMed", redMed);		}				private function appSetup() {			//_log.info("appSetup");						// create the first level			_levelScreen = new LevelScreen( _tm, _images, _sounds, 1, 4 );			_levelScreen.addEventListener("onLightLevel", _onLightLevel);			_levelScreen.addEventListener("onTallyReady", _onTallyReady);			_levelScreen.addEventListener("onCheckForObjects", _onCheckForObjects);			_levelScreen.addEventListener("onDeactivateTally", _onDeactivateTally);			this.addChild( _levelScreen );						// for attract loop			_attractLoopHolder = new Sprite();			this.addChild(_attractLoopHolder);			// video			var timeoutSecs = Number(AppConfig.getSetting("timeout_seconds"));			_idleTimer = new IdleTimeout(timeoutSecs);			//_idleTimer.addEventListener(IdleTimeout.IDLE_TIMEOUT, _attractLoopStartedHandler, false, 0, true);						_attractLoop = new AttractLoopVideo(_attractLoopHolder, _idleTimer, _videos["attract"].toString());			_attractLoop.addEventListener(AttractLoop.ATTRACT_STARTED, _attractLoopStartedHandler);						_idleTimer.start();			// start the loop			_attractLoop.start();						//this.addChild(_debugger);			//_debugger.appendText("app started\n");		}				private function _onCheckForObjects( ev:CustomEvent ):void {			trace("_onCheckForObjects");			// get a list of objects currently docked			_serial.send( "q" );		}				private function _onDeactivateTally( ev:CustomEvent ):void {			trace("_onDeactivateTally");			// tally button			_serial.send( "L4 0" );		}				private function _onTallyReady( ev:CustomEvent ):void {			trace("_onTallyReady");			// tally button			_serial.send( "L4 1" );		}				private function _onLightLevel( ev:CustomEvent ):void {			trace("_onLightLevel");			//trace("_onLightLevel: " + ev.params.level);			// send out which level lights to light			switch( ev.params.level ) {				case 1:					_serial.send( "L0 1" );					_serial.send( "L1 0" );					_serial.send( "L2 0" );					_serial.send( "L3 0" );					break;				case 2:					_serial.send( "L0 1" );					_serial.send( "L1 1" );					_serial.send( "L2 0" );					_serial.send( "L3 0" );					break;				case 3:					_serial.send( "L0 1" );					_serial.send( "L1 1" );					_serial.send( "L2 1" );					_serial.send( "L3 0" );					break;				case 4:					_serial.send( "L0 1" );					_serial.send( "L1 1" );					_serial.send( "L2 1" );					_serial.send( "L3 1" );					break;			}		}				private function _attractLoopStartedHandler(ev:Event):void {			// make sure the level 1 lights are on			_serial.send( "L0 1" );			// turn off all the lights			_serial.send( "L1 0" );			_serial.send( "L2 0" );			_serial.send( "L3 0" );			_serial.send( "L4 0" );						_timer.addEventListener(TimerEvent.TIMER_COMPLETE, _onAttractTimerEnd);			_timer.start();		}				private function _onAttractTimerEnd(ev:TimerEvent):void {			_timer.removeEventListener(TimerEvent.TIMER_COMPLETE, _onAttractTimerEnd);			if( !_active ) {				_active = true;				_levelScreen.attractLoop( "start" );				_levelScreen.visible = false;			}		}	}}