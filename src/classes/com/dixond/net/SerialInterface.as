package com.dixond.net {		/*	*	SerialInterface - Receives input from hardware via socket server / serial proxy (e.g. Tinkerproxy, Serproxy). 	*		- Reads and writes data as UTFBytes. Expects a constant stream of info delimited by a specified character (e.g. \n or \r). 	*		- Buffering code adapted from mike chambers: http://www.mikechambers.com/blog/2010/08/06/flash-arduino-tips-tricks-and-gotchas/	*		- Subclasses flash.net.Socket, so all those methods are available too...	*		- Dispatches event SerialInterface.SERIAL_DATA when data is recieved	*		- Can specify whether to automatically continue to attempt connection until successful or specific number of times.	*			*		*	*	@langversion ActionScript 3.0	*	@playerversion Flash 9.0	*	*	@author D. Dixon	*	@since  7.28.2010	*/		import flash.events.Event;	import flash.events.EventDispatcher;	import flash.events.ProgressEvent; 	import flash.events.IOErrorEvent; 	import flash.events.SecurityErrorEvent;	import flash.events.TimerEvent;	import flash.utils.Timer;	import flash.net.Socket;	import flash.errors.IOError;	import flash.errors.EOFError;  // the read functions all throw this error		import com.dixond.logging.Logger;	import com.dixond.events.CustomEvent;		public class SerialInterface extends Socket{		public static const SERIAL_DATA:String = "serial_data";		public static const CONNECT:String = "serial_connect";		public static const CONNECT_FAILED:String = "serial_connect_failed";				private var _log:Logger;		// the base url for all requests		private var _host:String;		private var _port:int;		private var _buffer:String = "";		private var _eomDelimiter:String = "\n";	// character that delineates the end of a message received from the hardware		private var _autoReconnect:Boolean; 		// if true will automatically repeat attempts to initiate a connection or re-establish a broken one		private var _autoConnectInterval:Number; 	// seconds between auto reconnect attempts		// private var _autoConnectAttempts:int; 		// max number of times to attempt to reconnect. Use 0 to try forever.  		private var _autoConnectTimer:Timer;		private var _connectAttemptCount:int=0;		// number of times we've tried to reconnect		private var _autoConnectTimeout:Number=0;	// seconds to keep trying reconnects. After this time auto attempts stop permanently. 0=forever				public function SerialInterface (aHost:String=null, aPort:int=0, aEomDelimiter="\n", aAutoReconnect:Boolean=true, aAutoConnectInterval:Number=5, aAutoConnectTimeout=0) {			super();			_log = Logger.getLog();			_host = aHost;			_port = aPort;			_eomDelimiter = aEomDelimiter;			_autoReconnect = aAutoReconnect;			_autoConnectInterval = aAutoConnectInterval;			_autoConnectTimeout = aAutoConnectTimeout;			// _autoConnectAttempts = aAutoConnectAttempts;			// _autoConnectTimer = new Timer(_autoConnectInterval * 1000, _autoConnectAttempts);						// determine how many times to try based on the time allowed by _autoConnectTimeout			var connectAttempts = _autoConnectTimeout / _autoConnectInterval; 			_autoConnectTimer = new Timer(_autoConnectInterval * 1000, connectAttempts);		        this.addEventListener(ProgressEvent.SOCKET_DATA, socketDataHandler, false, 1000); 	        this.addEventListener(Event.CONNECT, socketConnectHandler);	        this.addEventListener(Event.CLOSE, socketCloseHandler);	        this.addEventListener(IOErrorEvent.IO_ERROR, IOErrorHandler);	        this.addEventListener(SecurityErrorEvent.SECURITY_ERROR, securityErrorHandler);						// if a host/port was specified go ahead and connect			if (_host != null && _port != 0) {				this.connect(_host, _port);			} 		}				public override function connect(aHost:String, aPort:int):void {			_host = aHost;			_port = aPort;			_connectAttemptCount ++;			// log these as DEBUG to avoid filling log with these errors outside the DEBUG mode.			//_log.debug("Serial socket connecting to " + _host + ":" + _port + "..." + "(attempt:" + _connectAttemptCount + ").");						try {				super.connect(_host, _port);			} catch (e:Error) {				// not sure what triggers these errors to be thrown, but i can't get one to happen. Error events work tho...				//_log.error("Error thrown while connecting:" + e.message);			}		}				public function send(aStr:String) {			writeUTFBytes(aStr);			flush();		}					public function reconnect() {			// var str:String = _autoConnectAttempts + " times."			var str:String = "for " + _autoConnectTimeout + " seconds."			if (_autoConnectTimeout == 0) {				str = "indefinitely.";			}			//_log.error("Serial socket connection failed. Will retry to establish a connection " + str);			_connectAttemptCount = 0;			startAutoConnectTimer();		}				private function startAutoConnectTimer() {			_autoConnectTimer.addEventListener(TimerEvent.TIMER, autoConnectTimerHandler);			_autoConnectTimer.addEventListener(TimerEvent.TIMER_COMPLETE, autoConnectTimerCompleteHandler);			_autoConnectTimer.start();		}				private function stopAutoConnectTimer() {			_autoConnectTimer.removeEventListener(TimerEvent.TIMER, autoConnectTimerHandler);			_autoConnectTimer.removeEventListener(TimerEvent.TIMER_COMPLETE, autoConnectTimerCompleteHandler);			_autoConnectTimer.reset();		}				private function autoConnectTimerHandler(aEvent:TimerEvent):void {			this.connect(_host, _port);		}		private function autoConnectTimerCompleteHandler(aEvent:TimerEvent):void {			stopAutoConnectTimer();			// if we have reached the end of this timer, then no connection was made			//_log.error("Serial socket could not connect to " + _host + ":" + _port + " after attempting for " + _autoConnectTimeout + " seconds.");			_autoReconnect = false;		}				private function socketConnectHandler(aEvent:Event):void {			//_log.info("Socket connected to " + _host + ":" + _port + ".");			dispatchEvent(new CustomEvent(SerialInterface.CONNECT, {data:""}));			// stop the auto-connect timer once we've connected			stopAutoConnectTimer();		}				// parse the data received from hardware and disppatch an event		private function socketDataHandler(aEvent:ProgressEvent) {			var data:String = this.readUTFBytes( this.bytesAvailable );			//copy the newly arrived data into the buffer string.			_buffer += data;						//completed message from the server			var msg:String;			var index:int;			// loop through the buffer until it contains no more end of message delimiter			while( (index = _buffer.indexOf(_eomDelimiter)) > -1) {				//trace("end of line found");				//extract the message from the beginning to where the delimiter is				//we don't include the delimiter				msg = _buffer.substring(0, index);				//remove the message from the buffer				_buffer = _buffer.substring(index + 1);				// dispatch an event with the message as the data				dispatchEvent(new CustomEvent(SerialInterface.SERIAL_DATA, {data:msg}));			 	//_log.debug("SerialInterface.socketDataHandler()", "msg=" + msg.split(","));			}				}				private function socketCloseHandler(aEvent:Event) {			_log.error("Serial socket closed by server (" + _host + ":" + _port + ")");			if (_autoReconnect) {				reconnect();			}		}				private function IOErrorHandler(aEvent:IOErrorEvent) {			// not sure what various things trigger IO Errors, so this is an attempt to isolate connection failures from other io errors.			if (! connected) {				// log these as DEBUG to avoid filling log with these errors outside the DEBUG mode. End point errors will have higher priority.				_log.debug("Serial socket could not connect to " + _host + ":" + _port + "! " + aEvent.text);				dispatchEvent(new CustomEvent(SerialInterface.CONNECT_FAILED));				if ((_autoReconnect) && (!_autoConnectTimer.running)) {					reconnect();				}			} else {				_log.error("Serial socket IO Error (" + _host + ":" + _port + "). " + aEvent.text);			}		}				private function securityErrorHandler(aEvent:SecurityErrorEvent) {			_log.error("Serial socket Security Error (" + _host + ":" + _port + "). " + aEvent.text);		}			} //end class}//end package