package com.dixond.net {	/**	*   CustomSFClient - subclass of SmartFoxClient	*	Note about the order of events: connect, login, join room. Once room is joined we're ready to play...	*	Work in progress:	*		- may add config filepath as param. right now it's hard coded in as "config.xml"	*		- choice to autoload via loadConfig or handle load and connect separately? Right now it just autoConnects via loadConfig... And autoJoins...	*		* 	@langversion ActionScript 3	*	@playerversion Flash 9.0.0	*	*	@author D	*	@since  9.19.2008	*/	import flash.events.EventDispatcher;	import flash.events.Event;	import flash.events.TimerEvent;	import flash.utils.Timer;	import flash.events.IOErrorEvent;		import flash.events.SecurityErrorEvent;		import it.gotoandplay.smartfoxserver.SmartFoxClient;	import it.gotoandplay.smartfoxserver.SFSEvent;	import it.gotoandplay.smartfoxserver.data.Room;	import it.gotoandplay.smartfoxserver.data.User;			import com.dixond.logging.Logger;	import com.dixond.events.CustomEvent;	/** 	*	NOTE: Manages basic client connections and events via SmartFoxServer	*/	public class CustomSFClient extends SmartFoxClient  {		//--------------------------------------		// PROTECTED VARIABLES		//--------------------------------------		// message dispatched when client fails to connect, login or join room		public static var CUSTOM_SFCLIENT_FAIL:String = "custom_sfclient_fail";				// username assigned by server to this client. Is the name used to login unless none was specified.		private var _userName:String;		// ref to the server room all the action takes place in. 		private var _room:Room;		// for repeat connection attempts until connected		private var _connectionTimer:Timer;		// delay between connection attempts in milliseconds		private var _connectionIntervalMillis:uint;		// number of times to try connecting before giving up. -1 means to try indefinitely		private var _maxConnectAttempts:Number = -1;		// current number of attempts made		private var _attempts:Number = 1;				// timer to prevent kiosk from getting idle kicked from SFServer		private var _kickPreventionTimer:Timer;		// private var _kickPreventionSeconds:int = 120;				// name to use when attempting login. If successful, _userName should equal this name		private var _loginName:String;		// room to join can be a string (name of room) or number representing the room id (from RoomList)		private var _roomToJoin:*;		private var _roomPassword:String;				// if attempted connection fails at any point (connect, login, join), this object stores info to dispatch as event		// failpoint indicates which step the failure occured: connect, login, join. The message is the specific error message		// private var _failureObject:Object = {failpoint:null, message:null};				// logging		private var _log:Logger;				//--------------------------------------		//  CONSTRUCTOR		//--------------------------------------		/**		*	creates instance of the smartFoxClient and initializes event listeners for the various sf events		*/		public function CustomSFClient(aLoginName:String, aRoom:* = "default", aPassword:String = "", aMaxConnectAttempts:int=-1, aConnectInterval:uint=5000) {			super();			_log = Logger.getLog();			_loginName = aLoginName;			_roomToJoin = aRoom;			_roomPassword = aPassword;			// timer for repeat connect attempts			_connectionIntervalMillis = aConnectInterval; //5000;			_connectionTimer = new Timer(_connectionIntervalMillis, 1);			_maxConnectAttempts = aMaxConnectAttempts;			_connectionTimer.addEventListener(TimerEvent.TIMER, connectionTimerHandler);						// define event listeners			this.addEventListener(SFSEvent.onConfigLoadSuccess, onConfigLoadSuccessHandler);			this.addEventListener(SFSEvent.onConfigLoadFailure, onConfigLoadFailureHandler);			this.addEventListener(SFSEvent.onConnection, onConnectionHandler);			this.addEventListener(SFSEvent.onConnectionLost, onConnectionLostHandler);			this.addEventListener(SFSEvent.onLogin, onLoginHandler);			this.addEventListener(SFSEvent.onRoomListUpdate, onRoomListUpdateHandler);			this.addEventListener(SFSEvent.onJoinRoom, onJoinRoomHandler);			this.addEventListener(SFSEvent.onJoinRoomError, onJoinRoomErrorHandler);			this.addEventListener(SFSEvent.onUserEnterRoom, onUserEnterRoomHandler);			this.addEventListener(SFSEvent.onUserLeaveRoom, onUserLeaveRoomHandler);						this.addEventListener(SFSEvent.onPrivateMessage, onPrivateMessageHandler);			this.addEventListener(SFSEvent.onPublicMessage, onPublicMessageHandler);			this.addEventListener(SFSEvent.onAdminMessage, onAdminMessageHandler);			this.addEventListener(SFSEvent.onObjectReceived, onObjectReceivedHandler);				// // Register for generic errors			this.addEventListener(SecurityErrorEvent.SECURITY_ERROR, onSecurityError)			this.addEventListener(IOErrorEvent.IO_ERROR, onIOError)					}		// Not currently used		private function killConnectionTimer():void {			if (_connectionTimer != null){				_connectionTimer.removeEventListener(TimerEvent.TIMER, connectionTimerHandler, false);			}			_connectionTimer = null;		}				// stops connection timer without killing it or removing the listener		// this way we can re-use it if connection is dropped		private function stopConnectionTimer() {			if (_connectionTimer != null){				_connectionTimer.stop();			}		} 				private function startConnectionTimer() {		 	_log.info("Will retry connection in " + _connectionIntervalMillis/1000 + " seconds");			_connectionTimer.start();		}				private function connectionTimerHandler(aEvent:TimerEvent) {			_attempts ++;		 	connectToServer();		}				public function connectToServer():void {			// auto-connect to sf server by loading the config file			if (!this.isConnected) {				// debug ("attempting config load");				this.loadConfig("config.xml", true);			} else {				_log.warn ("You're already connected.");			}		}				public function reconnectToServer():void {					}				private function onSecurityError(aEvent:SecurityErrorEvent) {			_log.debug("Security Error at SmartFoxClient: " + aEvent.text);		}				private function onIOError(aEvent:IOErrorEvent) {			_log.debug("IO Error at SmartFoxClient: " + aEvent.text);		}				// this only gets dispatched if autoConnect is false.		// so if you're auto connecting you need to listen for onConnection and not this one.		private function onConfigLoadSuccessHandler(aEvent:SFSEvent) {			_log.debug("Client config file loaded. Connecting...");		}				// this gets called if sf can't load config file		private function onConfigLoadFailureHandler(aEvent:SFSEvent) {			_log.fatal("Failed to load client config file");			var msg = "Failed to load client config file";			fail("connect", msg);		}		private function onConnectionHandler(aEvent:SFSEvent) {			// _log.debug("onConnectionHandler()");			var success = aEvent.params.success;			var error = aEvent.params.error;			// login to default room, or alert to error			if (success) {				_log.info("Connected to SmartFox Server " + this.ipAddress + ":" + this.port + "! Attempting login as " + _loginName + " at zone " + this.defaultZone);				// test that zone exists. Warn if not. Otherwise we hang waiting for a login that aint happening and with no feedback from SFS				// Note this test only works if the zone is empty or the <zone> setting is missing in config file. 				// If it's just wrong or no such zone exists we keep hanging with no error event that i can seem to listen for...				if (this.defaultZone == null || this.defaultZone == "") {					msg = ("The default zone has not been specified. Check the config file for the <zone> setting.");					fail("login", msg);					_log.error(msg);				} else {					this.login(this.defaultZone, _loginName, _roomPassword);				}				// stop any further repeat attempts to connect				stopConnectionTimer();			} else {				// start the timer that will retry the connection 				if (_maxConnectAttempts < 1 || _attempts < _maxConnectAttempts) {					_log.error("Could not connect to SmartFox server at " + this.ipAddress + ":" + this.port + " Will retry in " + _connectionIntervalMillis/1000 + " seconds\n" + error);				startConnectionTimer();				} else {					var msg = (_attempts + " attempted connections failed at " + this.ipAddress + ":" + this.port + "! The server is probably not running.\n" + error);					_log.debug("failing at onConnectionHandler");					fail("connect", msg);				}			}		}				// note: no params available for this event. No feedback on who lost the connection.		// note logging into a non-existent zone appears to timeout and drop the connection and trigger this event instead of sending "onLogin" with a false success param		private function onConnectionLostHandler(aEvent:SFSEvent) {			_log.warn("Connection lost!");			// attempt to re-establish connection			_attempts = 1;			// attempt immediately to restablish connection to server			_log.warn("Attempting to reconnect...");			connectToServer()		}				// Note: this doesn't seem to fire if the target zone doesn't exist. What's the point then? We just hang waiting for a login that aint never gonna happen...		private function onLoginHandler(aEvent:SFSEvent) {			_log.debug("CustomSFClient.onLoginHandler()");			var success = aEvent.params.success;			var error = aEvent.params.error;			if (success) {				_userName = aEvent.params.name;				_log.info("Logged in as " + _userName);			} else {				_log.error ("Could not log in as '" + _userName + "'." + error);				var msg = "Could not log in as '" + _userName + "'." + error;				fail("login", msg);			}		} 				// follows successful login and indicates that rooms are available		// RoomList is useful when dealing with multiple rooms and you want to pick one to join.		// Otherwise automatically join the default spec'd in the server config file.		// Note: Currently this is set to ignore the RoomList and autoJoin the default room		private function onRoomListUpdateHandler(aEvent:SFSEvent) {			// _log.debug("CustomSFClient.RoomListUpdateHandler()");			if (_roomToJoin == null || _roomToJoin == "default" || _roomToJoin == "") {				_log.debug("Auto joining the default room.");				this.autoJoin();			} else {				// joinRoom(newRoom:*,pword:String = "",	isSpectator:Boolean = false, dontLeave:Boolean = false, oldRoom:int = -1) : void)				_log.debug("Joining room '" + _roomToJoin + "'");				this.joinRoom(_roomToJoin, _roomPassword);			}		}				private function onJoinRoomHandler(aEvent:SFSEvent) {			_log.info("Joined room " + aEvent.params.room.getName());			_room = aEvent.params.room;			// see if the projection client is already connected.		}				private function onJoinRoomErrorHandler(aEvent:SFSEvent) {			_log.error("Could not join room " + aEvent.params.room.getName());			var msg = "Could not join room " + aEvent.params.room.getName();			fail("join", msg);		}				// used primarily to detect if projectionClient is connected to server		private function onUserEnterRoomHandler(aEvent:SFSEvent) {			_log.debug("CustomSFClient.onUserEnterRoomHandler");		}		private function onUserLeaveRoomHandler(aEvent:SFSEvent) {			_log.debug(aEvent.params.userName + " has left the room.");		}				private function onPublicMessageHandler(aEvent:SFSEvent) {			_log.debug("CustomSFClient.onPublicMessageHandler()");		}				private function onPrivateMessageHandler(aEvent:SFSEvent) {			_log.debug("CustomSFClient.onPrivateMessageReceivedHandler()");		}				private function onAdminMessageHandler(aEvent:SFSEvent) {			// _log.debug (_userName + ": Admin message received! " + aEvent.params.message);		}				// event.params is an object that contains the following props:		//	- obj:Object -  the Actionscript object being received 		//	- sender:User - User object representing the uesr that sent the AS object		private function onObjectReceivedHandler(aEvent:SFSEvent) {			// _log.debug("CustomSFClient.onObjectReceivedHandler()");		}				// // TEMP		// private function listObject(aObj) {		// 	var lst = "";		// 	for (var prop in aObj) {		// 		// _log.debug("\t" + prop + " = " + aObj[prop]);		// 		lst += prop + ":" + aObj[prop] + " ";		// 	}		// 	return lst;		// }		private function fail(aFailpoint, aMsg) {			var obj = {failpoint:aFailpoint, message:aMsg}			dispatchEvent (new CustomEvent(CUSTOM_SFCLIENT_FAIL, obj));		}				// returns a list (object) with all the users in the current room that this client is in		public function getUsersInRoom() {			var room = this.getRoom(this.activeRoomId);			return room.getUserList();		}				// starts the timer that sends occasoinal messages to prevent being idle kicked by SFServer		public function enableKickPrevention(aKickPreventionSeconds:Number) {			// start the kick prevention timer			if (_kickPreventionTimer == null) {				_kickPreventionTimer = new Timer(aKickPreventionSeconds * 1000);				_kickPreventionTimer.addEventListener(TimerEvent.TIMER, kickPreventionTimerHandler);				_kickPreventionTimer.start();			}		}				private function kickPreventionTimerHandler(aEvent:TimerEvent) {			// just send a message			this.sendPublicMessage("Random message to prevent idle kick. ");		}				/**		 * 		 */		public function dispose():void {			// close the connection		}				public function get room() {			return _room;		}				public function get userName():String {			return _userName;		}			}// end class}// end package