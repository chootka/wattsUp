package com.dixond.utils{	import flash.display.DisplayObject;	import flash.display.DisplayObjectContainer;	import flash.display.MovieClip;	import flash.display.Bitmap;    import flash.display.BitmapData;    import flash.geom.Matrix;    import flash.geom.ColorTransform;    import flash.geom.Rectangle;	import com.dixond.utils.Stringd;		/**	*   Collection of static utility methods.	*		* 	@langversion ActionScript 3	*	@playerversion Flash 9.0.0	*	*	@author DDD	*	@since  14.07.2007	*/	public class Util {				public static function RGBtoARGB(aRGB:uint, aAlpha:uint):uint{		  //newAlpha has to be in the 0 to 255 range		  var argb:uint = 0;		  argb += (aAlpha<<24);		  argb += (aRGB);		  return argb;		}						// DO: CHANGE SOURCE TO IBitmapDrawable, SO WE CAN INCLUDE OTHER BITMAP DATA AS WELL AS DISPLAY OBJECTS AS THE SOURCE		// creates a new bitmap object from the bitmap data of another DisplayObject;		// if includeTransparency is false, any transparency is turned to black or specified fillColor (if fillColor is transparent, black is used)		// if includeTransparency is true, fill color is not used?		// ALERT: so far the includeTransform doesn't work. Image comes up blank. Debug this later...		public static function makeBitmap(aSource:DisplayObject, aIncludeTransparency:Boolean = true, aFill:Number=0x00000000, aIncludeTransform:Boolean=false, aIncludeBlendMode:Boolean = false, aClipRect:Rectangle=null):Bitmap {			var data = Util.getBitmapData(aSource, aIncludeTransparency, aFill, aIncludeTransform, aIncludeBlendMode, aClipRect);			return new Bitmap(data);					}				// returns the bitmap data from a DisplayObject		public static function getBitmapData(aSource:DisplayObject, aIncludeTransparency:Boolean = true, aFill:Number=0x00000000, aIncludeTransform:Boolean=false, aIncludeBlendMode:Boolean = false, aClipRect:Rectangle=null):BitmapData {			if (aIncludeTransform) {				var m = aSource.transform.matrix;				var c = aSource.transform.colorTransform;			} else {				m = new Matrix();				c = new ColorTransform();			}			if (aIncludeBlendMode) {				var b = aSource.blendMode;			} else {				b = null;			}						var data = new BitmapData(aSource.width, aSource.height, aIncludeTransparency, aFill);			// draw the source content to the BitmapData. May add the clipRect later if it seems useful			data.draw(aSource, m, c, b, aClipRect);			return data;		}		import flash.utils.ByteArray; 		// From Adobe Help. Does deep copying. The algorithm is borrowed from a common Java programming technique. The function creates a deep copy by serializing the array into an instance of the ByteArray class, and then reading the array back into a new array. 		// This function accepts an object so that it can be used with both indexed arrays and associative arrays		public static function cloneObject(source:Object):* { 		    var ba:ByteArray = new ByteArray(); 		    ba.writeObject(source); 		    ba.position = 0; 		    return(ba.readObject()); 		}				public static function arrayContains(aArray:Array, aElement:*, aFromIndex:int=0) {			return (aArray.indexOf(aElement, aFromIndex)) != -1		}				public static function duplicateArray(aArray:Array):Array {			var dupeArray = [];			for each (var item in aArray) {				dupeArray.push(item);			}			return dupeArray;		}		/**		*	returns the highest numeric value in the array.		*	currently sorts ints only.		*	NOTE: Sorting does not work on floats! Ints only!		*/		public static function arrayMax(aArray:Array) {			aArray.sort(Array.NUMERIC);			return aArray[aArray.length - 1];		}		/**		*	returns the lowest numeric value in the array.		*	sorts ints only. In ascending order		*	NOTE: Sorting does not work on floats! Ints only!		*/		public static function arrayMin(aArray:Array) {			aArray.sort(Array.NUMERIC);			return aArray[0];		}		/**		*	returns the sum of all numerical values in an array.		*/		public static function arraySum(aArray:Array) {			var sum = 0;			for each(var val in aArray) {				if ( !isNaN(Number(val)) ){					sum += val;				}			}			return sum;		}				/**		*	removes all display object from the display list of specified object.		*/		public static function removeAllChildren(aContainer:DisplayObjectContainer) {			if (aContainer != null) {				while (aContainer.numChildren > 0) {					aContainer.removeChildAt(0);				}			}		}				/**		*	removes the specified display object from whichever display list it's on.		*/		public static function removeDisplayObject(aDisplayObj:DisplayObject) {			if (aDisplayObj != null) {				// trace("Util.removeDisplayObject()", "obj=" + aDisplayObj, "parent=" + aDisplayObj.parent);				if (aDisplayObj.parent != null) { 					aDisplayObj.parent.removeChild(aDisplayObj);				}			}		}				/**		 * duplicateMovieClip		 *	Identical to duplicateDisplayObject below, just accecpts MovieClip as arg		 * @param source the display object to duplicate		 * @param autoAdd if true, adds the duplicate to the display list		 * in which source was located		 * @return a duplicate instance of source		 *	http://www.dannyburbol.com/2009/01/movieclip-clone-flash-as3/		 */		public static function duplicateMovieClip(source:MovieClip, autoAdd:Boolean = false):MovieClip	{		    // create duplicate		    var sourceClass:Class = Object(source).constructor;		    var duplicate:MovieClip = new sourceClass();		    // duplicate properties		    duplicate.transform = source.transform;		    duplicate.filters = source.filters;		    duplicate.cacheAsBitmap = source.cacheAsBitmap;		    duplicate.opaqueBackground = source.opaqueBackground;		    if (source.scale9Grid) {		        var rect:Rectangle = source.scale9Grid;		        // WAS Flash 9 bug where returned scale9Grid is 20x larger than assigned		        // rect.x /= 20, rect.y /= 20, rect.width /= 20, rect.height /= 20;		        duplicate.scale9Grid = rect;		    }		    // add to source parent's display list		    // if autoAdd was provided as true		    if (autoAdd && source.parent) {		        source.parent.addChild(duplicate);		    }		    return duplicate;		}				/**		 * duplicateDisplayObject		 * creates a duplicate of the DisplayObject passed.		 * similar to duplicateMovieClip in AVM1		 * @param source the display object to duplicate		 * @param autoAdd if true, adds the duplicate to the display list		 * in which source was located		 * @return a duplicate instance of source		 *	http://www.dannyburbol.com/2009/01/movieclip-clone-flash-as3/		 */		public static function duplicateDisplayObject(source:DisplayObject, autoAdd:Boolean = false):DisplayObject	{		    // create duplicate		    var sourceClass:Class = Object(source).constructor;		    var duplicate:DisplayObject = new sourceClass();		    // duplicate properties		    duplicate.transform = source.transform;		    duplicate.filters = source.filters;		    duplicate.cacheAsBitmap = source.cacheAsBitmap;		    duplicate.opaqueBackground = source.opaqueBackground;		    if (source.scale9Grid) {		        var rect:Rectangle = source.scale9Grid;		        // WAS Flash 9 bug where returned scale9Grid is 20x larger than assigned		        // rect.x /= 20, rect.y /= 20, rect.width /= 20, rect.height /= 20;		        duplicate.scale9Grid = rect;		    }		    // add to source parent's display list		    // if autoAdd was provided as true		    if (autoAdd && source.parent) {		        source.parent.addChild(duplicate);		    }		    return duplicate;		}							// 	    /**			// 	     * duplicateDisplayObject			// 	     * creates a duplicate of the DisplayObject passed.			// 	     * similar to duplicateMovieClip in AVM1			// 	     * @param target the display object to duplicate			// 	     * @param autoAdd if true, adds the duplicate to the display list			// 	     * in which target was located			// 	     * @return a duplicate instance of target			// 	     *				// 	     *	usage: 			// 	     *	var newInstance:Sprite = duplicateDisplayObject(myOldSprite, true);			// 	     *	newInstance.x += 100; // shift to see duplicate 			// 					// 	     */			// 	    public static function duplicateDisplayObject(target:DisplayObject, autoAdd:Boolean = false, ... args):DisplayObject {			// 	        // create duplicate			// 	        var targetClass:Class = Object(target).constructor;			// 	        // var duplicate:DisplayObject = new targetClass();			// trace("TARGET = " + targetClass, "TARGET = " + target);			// return target;			// // allow the passing of parameters to duplicate custom objects			// var duplicate:DisplayObject = targetClass.call(target, args);			// 	        			// 	        // duplicate properties			// 	        duplicate.transform = target.transform;			// 	        duplicate.filters = target.filters;			// 	        duplicate.cacheAsBitmap = target.cacheAsBitmap;			// 	        duplicate.opaqueBackground = target.opaqueBackground;			// 	        if (target.scale9Grid) {			// 	            var rect:Rectangle = target.scale9Grid;			// 	            // WAS Flash 9 bug where returned scale9Grid is 20x larger than assigned			// 	            // rect.x /= 20, rect.y /= 20, rect.width /= 20, rect.height /= 20;			// 	            duplicate.scale9Grid = rect;			// 	        }			// 			// 	        // add to target parent's display list			// 	        // if autoAdd was provided as true			// 	        if (autoAdd && target.parent) {			// 	            target.parent.addChild(duplicate);			// 	        }			// 	        return duplicate;			// 	    }		/**		*	Writes the display list hierarchy of a DisplayObject		*	@param do the displayObject		*	@returns dot delimited string of object's path starting at the stage		*	@example stage.root1.title_mc.text		*/		public static function getDisplayObjectPath(aDo:DisplayObject):String {			//trace ("*** GETTING PATH ***");			var path:Array = [aDo.name];			var container:DisplayObject = aDo;			do {				container = container.parent;				//stage doesn't have a name so we'll add it manually				if (container == aDo.stage) {					var dispObjName = "stage";				}else {					dispObjName = container.name;				}				path.unshift(dispObjName);			} while (container != aDo.stage);			// join array to a dot delimited string			return path.join(".");		}						//==================================		// searchObject - searches an object or associative array for a specified property. 		// Objects or associative arrays can't be searched by index numbers. Only by properties.		// returns: the value of the specified property if that property is found; null if not.		// Note: as currently written, a return value of null could indicate an actual null value for that property or that the prop was not found. Do we need to revisit this. But it seems that any value could be a valid value vs indicator of failure. (e.g. -1...)		//==================================		public static function searchObject(aObject,aProp) {			for (var prop:String in aObject) {				if (prop == aProp) {					return aObject[prop];				}			}			// if we didn't return anything then the prop is not here			return null;		}		//		//==================================		// getObjectProp - returns the the property name for the given value. Note will only return the first occurance.		//==================================		public static function getObjectProp(aObject:Object,aValue:Object) {			for (var prop:String in aObject) {				if (aObject[prop] == aValue) {					return prop;				}			}			return null;		}		//		//==================================		// getObjectLength - returns the number of items (properties) in an object or associative array		//==================================		public static function getObjectLength(aObject) {			//debug("getObjectLength()");			if (aObject is Object) {				var n=0;				for (var prop:String in aObject) {					n++;				}			}			return n;		}		// =================================		// duplicateObject - returns a duplicate copy of specified object		// =================================		public static function duplicateObject(aObject) {			if (aObject == null) {				return;			}			var o:Object=new Object;			for (var prop in aObject) {				o[prop]=aObject[prop];			}			return o;		}				// =================================		// stringToObject - converts a string representation of an object into an actual Object		// may be able to do this more consisely w reg exp...		// currently doesnt work if commas are in the values...		// =================================		function stringToObject(aStr) {			// Remove the "{" and "}":			var convertString:String = aStr.slice(1, aStr.length - 1);			var items:Array = convertString.split(",");			var obj:Object = new Object();			for (var i in items) {				var props:Array = items[i].split(":");				obj[props[0]] = props[1].slice(1, props[1].length - 1);// remove quotes			}			// // trace out the objects props and values			// for (var prop in obj) {			// 	trace(prop + ":" + obj[prop]); 			// }			return obj;		}				// =================================		// recurseTrace - recursively traces an object. From flash article online		// =================================		public static function recurseTrace(info:Object, indent:String):void {			for (var i:* in info) {				if (typeof info[i] == "object") {					trace(indent + i + ":");					recurseTrace(info[i], indent + " ");				} else {					trace(indent + i + " : " + info[i]);				}			}		}				// =================================		// recurseGet - recursively traces an object. Based on recurseTrace above but returns the results as string		// =================================		public static function recurseGet(info:Object, indent:String):String {				var str = "";			for (var i:* in info) {				if (typeof info[i] == "object") {					// trace(indent + i + ":");					str += (indent + i + ":" + "\n");					str += recurseGet(info[i], indent + " ");				} else {					// trace(indent + i + " : " + info[i]);					str += (indent + i + " : " + info[i] + "\n");				}			}			return str;		}				// =================================		//  traceObject - simply lists the objects properties and values to the output window. 		// 	aHeader - an optional string to output before the object trace		//  Not recursive, so doesn't do nested objects.				// =================================		public static function traceObject(aObj:Object, aHeader:String = null) {			trace("======================");			if (aHeader != null) {				trace(aHeader);			}			for (var prop in aObj) {				trace(prop + ": " + aObj[prop]);			}			trace("======================");		}				// =================================		// getObjectAsString - recursively converts an object to a string. Based on recurseTrace above but returns a string rep of the object		// This only seems to work sporadically!! Can't rely on it cuz sometimes it reports empty objects when they're not! Ugh!		// thinking this doesn't work with Class objects. Only with the generic dynamic objects using Object() or {} syntax. bummer...		//  DO: HAS NOT YET BEEN TESTED ON NESTED OBJECTS...		//  DO: MAKE reorder AN OPTIONAL PARAMETER. REMOVE THE INDENTING		// =================================		public static function getObjectAsString(info:Object, indent:String = ""):String {			var str = "";			// reverse the object so we can show things in the correct order.			info = reverseObject(info);			for (var prop:* in info) {				// if (typeof info[prop] == "object") {				if (info[prop] is Object) {					// trace(indent + i + ":");					// str += (indent + i + ":" + "\n");					str += getObjectAsString(info[prop], indent + " ");				} else {					trace("prop", prop);					// trace(indent + i + " : " + info[i]);					// quote strings if nec					var val = info[prop];					if (val is String) {						val = "'" + info[prop] + "'";					}					str += (indent + prop + ": " + val + ", ");				}				// trace("***Util.getObjectAsString()", "prop=" + prop);			}			// remove the trailing comma			str = str.slice(0, str.length - 2);			str = "{" + str + "}"			return str;		}				// =================================		// 	reverseObject - simply remakes the object with the items in the reverse order. For some reason flash reads objects backwards. Sometimes we just don't want that...		// =================================		public static function reverseObject(aObj:Object) {			var newObj:Object = {}			for(var prop in aObj) {				newObj[prop] = aObj[prop];			}			return newObj;		}			}// end class}// end package