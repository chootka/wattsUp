package com.dixond.utils{	//import com.dixond.utils.Util;	/**	* A class of useful static math and math-like methods	* <p> 7/65/07 AS3 update <p>	* DO: <br>	* Add / adjust types for params and return vals. <br>	*     Look up anything new in Math class that would negate any function here.	*/	public class Mathd {		/**		*	returns the average of specified parameters		*	@params can be a single array argument, or a series of number arguments		*			*/		public static function average(...args):Number {			var sum:Number = 0;			// if an array was passed instead of separate args, use that			if (args[0] is Array) {				args = args[0];			} 						for (var i = 0; i < args.length; i++) {				sum += args[i];			}			return sum / args.length;		}				/**		*   scaleValue: Scales original value to a new value within the range of specified numbers		*   note: modified 7/2006:		*       1. fixed adjustedOrigVal so newVal properly constrains to newMin.		*       2. constraining to new vals is now optional via parameter.		*/		public static function scaleValue(origVal:Number, origMin:Number, origMax:Number, newMin:Number, newMax:Number, constrain:Boolean=true):Number {			//debug("scaleValue", origVal, origMin, origMax, newMin, newMax);			var origRange = Math.abs(origMax - origMin);			var newRange = Math.abs(newMax - newMin);			var scale = newRange / origRange;			// account for ranges that don't start with 0 (e.g  100 - 200)			var adjustedOrigVal = (origVal - origMin);			if (newMin < newMax) {				var newVal = (adjustedOrigVal * scale) + newMin;			} else if (newMin > newMax) {				newVal = newMin - (adjustedOrigVal * scale);			}			if (constrain) {				// constrain value to not less than newMin and not more than newMax				// account for newMin and mewMax vals that may have been passed in reverse order to get reversed scale				var realMin = Math.min(newMin, newMax);				var realMax = Math.max(newMin, newMax);				// now constrain the new val between or equal to the realMin and realMax				newVal = Math.min(newVal, realMax);				newVal = Math.max(newVal, realMin);			}			return newVal;		}				/**   		*   constrainValue: constrains specified value to within specified min and max values		*/		public static function constrainValue(aVal, aMin, aMax) {			var newVal = Math.min(aVal, aMax);			return Math.max(newVal,aMin);		}				/**  		*   returns a random number between min and max, inclusive		*/		public static function randomRange(min:Number, max:Number):Number {			if (min > max) {				var temp:Number = min;				min = max;				max = temp;			}			// return Math.floor(Math.random() * max - min + 1) + min;			// return Math.floor(Math.random()*(max-min+1)) + min;		    return (Math.floor(Math.random() * (max - min + 1)) + min);		}		/**   		*   convert radians to degrees		*/		public static function toDegrees(aRadians) {			return aRadians * 180 / Math.PI;		}		/**  		*	 convert degrees to radians		*/		public static function toRadians(aDegrees) {			return aDegrees * Math.PI / 180;		}				public static function millisToHms (aMillis) {			// forgot to note where i got this...			//Convert duration from milliseconds to 0000:00:00.00 format			var hms = "";			var dtm = new Date(); 			dtm.setTime(aMillis);			var h = "000" + Math.floor(aMillis / 3600000);			var m = "0" + dtm.getMinutes();			var s = "0" + dtm.getSeconds();			var cs = "0" + Math.round(dtm.getMilliseconds() / 10);						hms = h.substr(h.length-4)+":"+m.substr(m.length-2)+":";			hms += s.substr(s.length-2)+"."+cs.substr(cs.length-2);				return hms		}		/**   =================================		*   returns positive atan values between 0 and 2PI (instead of between PI and -PI as returned by Math.atan2())		*   this gives us positive values spanning the full circle.		*   alternative to Math.atan2 that returns values between 0 and 2*PI (which can be converted to 0 - 360).		*/		public static function atan3(y, x) {			var angle = Math.atan2(y, x);			// if the angle is negative (between 0 and -PI), convert it to the cooresponding pos values of the rest of the circle			if (angle < 0) {				angle += (2 * Math.PI);			}			//Util.debug("atan3()", "*plain atan", Math.atan2(y, x), Mathd.toDegrees(Math.atan2(y, x)), "*angle", angle, Mathd.toDegrees(angle));			return angle;		}		/**  		*   convert liters to gallons		*/		public static function litersToGallons(aLiters:Number) {			return aLiters * 0.264172051;		}		/**  		*   convert gallons to liters		*/		public static function gallonsToLiters(aGallons:Number) {			return aGallons * 3.7854118;		}				//		// end class	}	// end package}