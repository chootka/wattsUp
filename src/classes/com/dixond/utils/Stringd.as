package com.dixond.utils{	//import com.dixond.utils.Util;	/**	Textd Class	Some static String related util functions	AS3 Update	7/3/07	*	Updated May 4, 2010 - added replaceString() and replaceStrings()	== DO:		*/	public class Stringd {				// just a more readable version to having to do this test all the time		public static function contains(aStr:String, aSearchString:String):Boolean {			return (aStr.indexOf(aSearchString) > -1);		}				// Replaces a single search string with the replacement string. 		// If multiple replaceItems are specified they will replace multiple occurances of the search string if found. Otherwise, only the first instance of the searchStr is replaced.		// Thanks to RegExp code from an ultrashock forum comment here: http://www.ultrashock.com/forum/viewthread/92968/		public static function replaceString(str:String, searchStr:String, ...replacementItems) {			trace("====testReplace===", replacementItems.length);			var replacementItemCount:int = replacementItems.length;			var pattern:RegExp;			var flags:String = "si";			var i:int = -1;			while ( ++ i < replacementItemCount ) {				trace("i", i);				pattern = new RegExp(searchStr,flags);				str = str.replace(pattern,replacementItems[i]);			}			return str;		}		// Replaces multiple search strings with the corresponding replacementStrings		public static function replaceStrings(str:String, searchStrings:Array, replacementStrings:Array) {			var newStr = str;			trace(newStr);			trace(newStr.split(searchStrings));			var arr:Array;			var itemCount = replacementStrings.length;			// might want to test if both arrays match in length			for (var i=0; i< itemCount; i++) {				newStr = newStr.split(searchStrings[i]).join(replacementStrings[i]);			}			return newStr;		}						/**		*	formats a number as a currency string. E.g. 4 = $4.00 or 3.72233 = 3.72		*	 defaults to US prefix, but can specify any prefix character		*/		public static function toCurrencyString(aNum:Number, aPrefix = "$"):String {			return String(aPrefix + aNum.toFixed(2)); 		}				/**		*	returns true if the specified string ends in a number		*/		public static function endsWithNumber(aSourceString:String) {			var pattern:RegExp = /\d+$/;			return aSourceString.match(pattern) != null;		}				/**		*  returns copy of aStr with the first letter capitalized and all others lowercase		*  aPreserve is optional boolean. If true, will preserve the original case of all but first char 		*  e.g. "mixedCaseWord" would become:  "Mixedcaseword" by default, and  "MixedCaseWord" if aPreserve is true		*/		public static function firstUpperCase(aStr:String, aPreserve:Boolean=false) {			var newStr:String = aStr.charAt(0).toUpperCase();			// convert the rest			if (aPreserve) {				newStr += aStr.slice(1);			} else {				newStr += aStr.slice(1).toLowerCase();			}			return newStr;		}		/**		*  adds padStr to the beginning of aStr until aStr is aTotalDigits in length		*	note: this currently assumes the padStr is only one char. Does not account for otherwise. 		*/		public static function pad(aStr:String, aPadStr:String, aTotalDigits:uint) {			var len:int = aStr.length;			if (len < aTotalDigits) {				for (var i:uint = 0; i < aTotalDigits - len; i++) {					aStr = aPadStr + aStr;				}			}			return aStr;		}		/**		*  removes any leading and trailing whitespace including tabs, spaces and the various linebreaks		*  DO: re-write this adding all chars to test for to an array		*/		public static function trimWhitespace(aTxt) {			//debug("TM.trimWhitespace()", aTxt);			// remove any leading whitespace including tabs, spaces and the various linebreaks			while (aTxt.charCodeAt(0) == 9 || aTxt.charCodeAt(0) == 10 || aTxt.charCodeAt(0) == 12 || aTxt.charCodeAt(0) == 13 || aTxt.charCodeAt(0) == 23) {				aTxt = aTxt.substr(1, aTxt.length);			}			// remove any trailing whitespace including tabs, spaces and the various linebreaks			var endPos = aTxt.length - 1;			while (aTxt.charCodeAt(endPos) == 9 || aTxt.charCodeAt(endPos) == 10 || aTxt.charCodeAt(endPos) == 12 || aTxt.charCodeAt(endPos) == 13 || aTxt.charCodeAt(endPos) == 23) {				aTxt = aTxt.substr(0, aTxt.length - 1);				endPos = aTxt.length - 1;			}			return aTxt;		}		/**		*  returns aStr surrounded by quotation marks. Single quotes is the default.		*  aUseDoubleQuotes is an optional boolean. If true double quotes are used.		*/		public static function quote(aStr:String, aUseDoubleQuotes:Boolean=false) {			if (aUseDoubleQuotes) {				var char = '"';			} else {				// default				char = "'";			}			return char + aStr + char;		}		/**		*	formats number as a comma separated string - with commas separating every 3 digits.		*	Note: works w ints and floats (though, not sure you'd want to formats floats this way??)		*/		public static function commaFormat(aNumber:Number):String {			var numString:String = String(aNumber);			// find the num digits in the number, or before the decimal point if number is a float			var digits = numString.indexOf(".");			if (digits == -1){				digits = numString.length;			}			var insertPositions:Array = [];			// find each position were a comma should be inserted.			// start from the back of the number so the positions are in descending order			for (var i = digits -3; i >0; i-=3){				insertPositions.push(i);			}			// make sure the indexes are in descending by sorting them. (Prob not necessary; i'm just paranoid.)			insertPositions.sort(Array.NUMERIC | Array.DESCENDING);			// insert the commas.			var numArray:Array = numString.split("");			for each (var pos in insertPositions ) {				numArray.splice(pos, 0, ",");			}			return numArray.join("");		}						/**		*	assembles an array of filenames based on passed criteria		*	note punctuation is not assumed. Be explicit with the slashes, underscores and dots!		*	currently assumes a padding of at least one 0 in the file names: e.g. 01, 02... 		*		-will automatically adjust the padding depending on the total num of digits in the file count, unless aAutoPad is set to false, in which case you specify the total digits desired		*	@param parts - array that specifies the order of the parts of the filename. The options are: "path", "base", "index", "ext"		*	@apram details - object that specifies the specific values of the parts in the parts array (exept "index", which is calculated automatically). 		*	@count - total number of files		*	@startIndex - number of first file in sequence		*/			public static function assembleFilenameArray(aParts:Array, aDetails:Object, aCount:uint, aStartIndex:uint, aAutoPad:Boolean = true, aDigits:uint = 1) {			var fileNames:Array = [];			// pad with at least one 0, meaning indexes fo at least 2 digits. MAY MAKE THIS AN OPTION 			var totalDigits:uint = String(aCount).length;			if (aAutoPad) {				totalDigits = Math.max(totalDigits, 2);			} else {				totalDigits = Math.max(totalDigits, aDigits);			}			// adjust the end index so we make the correct num of files no matter what the startIndex is.			var endIndex = aStartIndex + aCount - 1;					for (var i = aStartIndex; i <= endIndex; i++) {				var fileStr = "";				for (var j = 0; j < aParts.length; j++) {					var thisPart = aParts[j];					if (thisPart == "index") {						var indexStr = i;						// if (aAutoPad) {						indexStr = Stringd.pad(indexStr, "0", totalDigits);						// }						fileStr += indexStr;					} else {						fileStr += aDetails[thisPart];					}				}				fileNames.push(fileStr);			}			return fileNames;		}		// public static function assembleFilenameArray(aParts:Array, aDetails:Object, aCount:uint, aStartIndex:uint, aAutoPad:Boolean = true, aDigits:uint = 2) {		// 	var fileNames:Array = [];		// 	// pad with at least one 0, meaning indexes fo at least 2 digits. MAY MAKE THIS AN OPTION 		// 	var totalDigits:uint = String(aCount).length;		// 	if (aAutoPad) {		// 		totalDigits = Math.max(totalDigits, 2);		// 	} else {		// 		totalDigits = Math.max(totalDigits, aDigits);		// 	}		// 	// adjust the end index so we make the correct num of files no matter what the startIndex is.		// 	var endIndex = aStartIndex + aCount - 1;		// 			// 	for (var i = aStartIndex; i <= endIndex; i++) {		// 		var fileStr = "";		// 		for (var j = 0; j < aParts.length; j++) {		// 			var thisPart = aParts[j];		// 			if (thisPart == "index") {		// 				var indexStr = i;		// 				if (aAutoPad) {		// 					indexStr = Stringd.pad(indexStr, "0", totalDigits);		// 				}		// 				fileStr += indexStr;		// 			} else {		// 				fileStr += aDetails[thisPart];		// 			}		// 		}		// 		fileNames.push(fileStr);		// 	}		// 	return fileNames;		// }								}// end class}// end package