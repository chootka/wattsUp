package com.dixond.display {import flash.display.*;import flash.events.*;import flash.geom.Point;import flash.geom.Rectangle;import com.dixond.display.MediaLoader;import com.dixond.utils.Mathd;import com.dixond.events.SliderEvent;import com.dixond.logging.Logger;/* ==============Slider Class8/06/2006== Class to create re-usable customizable sliders via external swfs or movieClip symbols in Library== Must supply a source (path to an .swf file OR linkage id of a movieclip library symbol). Source must contain the following movieClip instances on it's stage: 1) a Handle movieclip named 'handle_mc' to be dragged. It's _y position should be set as desired as it will not be altered.  2) a Track movieclip named 'track_mc' that defines the drag limits of the handle. (This clip need not be visible). Slider values are calculated based on this movieClip.== OPTIIONAL ELEMENTS - hitArea_mc - A movieClip that defines a rect that when clicked on, the slider handle jumps to that position, the value is updated, and the 'sliderChange' event triggered. - Defaults to be inactive when invisible. Can set this by calling the setActiveIfInvisible(boolean) function. - The slider swf file may also contain other graphics that are not referenced by this class.== See constructor for init parameters.// == EVENTS DISPATCHED:== 'sliderInit' - when the slider is loaded and initialized. Passes the following properties- target: object sending the event- type: type of event. This will always be the string "sliderInit"== 'sliderChange' - whenever the value changes. Passes the following properties:- target: object sending the event- type: type of event. This will always be the string "sliderChange"- sliderValue: number between 0 and 1 (or between _valueRange.min and _valueRange.max) representing the position of handle_mc's _x loc (based on it's regpoint) relative to track_mc.*	// ==== History ==== //*	6/13/2011 - added ability to accept either movieClip or sourcePath to load. Changed the args of the constructor to omit the source and added setSource() function. *	9/25/2008 - added ability to snap to specified increments. *	1/07/2008 - AS3 update*	1/??/07 - added aDontTriggerEvent param to updateSlider(). Gives ability to set the slider value without triggering the change event.*	1/31/07 		- added optionsl hitArea_mc for option to make slider jump to click points 		- slider clip now defaults to not respond to mouse input if it's invisible 		- added _activeIfInvisible prop and setActiveIfInvisible() function to control change the default behavior*/	public class Slider extends Sprite {		// ===== PROPERTIES ===== //		// loader that loads the slider swf		private var _loader:Loader;		// ref to the container clip into which the slider file is loaded		private var _sliderClip:MovieClip;		// flag that when true, slider value updates as mouse moves		private var _sliderActive;		// percentage val based on handle position within _sliderClip		private var _sliderValue;		// bounding rect of track_mc - for constraints and value calculation		private var _trackBounds:Rectangle;		// value to init the slider to. Will send a 'sliderChanged' event as normal.		private var _initialValue;		// object containing pre determined min and max values for the slider. If not specified, a range of 0 - 1 is used.		private var _valueRange:Object;		// determines if the slider responds to mouse input when invisible. Default is FALSE.		private var _activeIfInvisible:Boolean;		// increment for snapping. Note snapping likely won't work if slider ranges are not ints.		private var _increment:Number		// ===== CONSTRUCTOR ===== //		// == params:		// aSource (String) - file path to external swf		// aMin - minimum slider value		// aMax - max slider value		// aInitialValue - a value between 0 and 1 to set slider to at init time. Will instigate a 'changeed' event as if it was set by interaction.		public function Slider(aMin:Number, aMax:Number, aInitialValue:Number, aIncrement:Number = Number.NaN) {		// public function Slider(aSourcePath:String, aMin:Number, aMax:Number, aInitialValue:Number, aIncrement:Number = Number.NaN) {			// store the init val so we can set it when the slider's made			_initialValue = aInitialValue;			_valueRange = new Object();			_valueRange.min = aMin;			_valueRange.max = aMax;			_activeIfInvisible = false;			_increment = aIncrement;		}				// loads the slider MovieClip from an external file		public function setSource(aSourceClipOrPath:*, isMovieClip:Boolean) {			if (isMovieClip) {				// assign the movieClip directly				_sliderClip = aSourceClipOrPath as MovieClip;				initSlider();			} else {				// load the file that will serve as our slider				_loader = new MediaLoader(aSourceClipOrPath);				_loader.contentLoaderInfo.addEventListener(Event.INIT, sliderLoadInitHandler);			}		}				// ===== LISTENER FUNCTIONS ===== //				// event handler called when loaded clip is done loading its content		private function sliderLoadInitHandler(aEvent:Event) {			var ldr = aEvent.target.loader as Loader			_sliderClip = ldr.content as MovieClip;			initSlider();		}				private function initSlider() {			// Logger.getLog().debug("Slider.initSlider()", "this: "+ this, "clip: " + _sliderClip, "initial value: " + _initialValue);			this.addChild(_sliderClip);						_sliderActive = false;		 	_trackBounds = _sliderClip.track_mc.getBounds(_sliderClip);		 	_trackBounds = new Rectangle(_sliderClip.track_mc.x, _sliderClip.track_mc.y, _sliderClip.track_mc.width, _sliderClip.track_mc.height);					// set slider to init value or min value here??					if (_initialValue != null) {				setValue(_initialValue);			} else {				setValue(_valueRange.min);			}						// we'll hitTest these against the sliderClip to determine interaction			this.addEventListener(MouseEvent.MOUSE_DOWN, mouseDownHandler);			this.addEventListener(MouseEvent.MOUSE_UP, mouseUpHandler);			this.addEventListener(MouseEvent.MOUSE_MOVE, mouseMoveHandler);						// BUG: for some reason, if we use the movieClip directly this event doesn't get received by the listener. Yet it is received by the same listener when loading in external content.					dispatchEvent(new SliderEvent(SliderEvent.SLIDER_INIT));		}				//		// When handle is pressed, activates slider to allow handle dragging. 		// When bar is pressed, snaps handle to mouse and updates slider value		// note: this will register mouse activity when invisible, only if _activeIfInvisible is true		private function mouseDownHandler(aEvent:MouseEvent):void {			// Logger.getLog().debug("Slider.mouseDownHandler()");			if (!this.visible && !_activeIfInvisible) {				return;			}			// simulate onReleaseOutside by listening to stage for mouseUp event			this.stage.addEventListener(MouseEvent.MOUSE_UP, mouseUpHandler);			// add a stage listener to listen for mouse movement so we can keep updateing slider on mouseMove until user releases mouse, even if they overshoot the bounds of slider			this.stage.addEventListener(MouseEvent.MOUSE_MOVE, mouseMoveHandler);			// deal w mouseDown			var localMouse = new Point(this.mouseX, this.mouseY);			var globalMouse = this.localToGlobal(localMouse);			// test if handle is pressed			if (_sliderClip.handle_mc.hitTestPoint(globalMouse.x, globalMouse.y, true)) {				activateSlider();				// sendEvent("sliderPress");				dispatchEvent(new SliderEvent(SliderEvent.SLIDER_PRESS, _sliderValue));			}			// test if bar is clicked 			if (_sliderClip.hitArea_mc.hitTestPoint(globalMouse.x, globalMouse.y, true)) {				// sendEvent("sliderPress");				dispatchEvent(new SliderEvent(SliderEvent.SLIDER_PRESS, _sliderValue));				updateSlider(_sliderClip.mouseX);				activateSlider();			}		}		//		function mouseUpHandler(aEvent:MouseEvent):void {			Logger.getLog().debug("Slider.mouseUpHandler()");			var targ = aEvent.target as DisplayObject;			if (targ == this || this.contains(targ)) {				// released mouse over the slider or one of it's children				// trace("mouseup");								if (!this.visible && !_activeIfInvisible) {					return;				}				// make sure it was actually clicked on the slider first. Otherwise ANY mouseUp will trigger dispatch of the sliderRelease event! 				if (_sliderActive) {					deactivateSlider();					// sendEvent("sliderRelease");					dispatchEvent(new SliderEvent(SliderEvent.SLIDER_RELEASE, _sliderValue));				}			} else {				// released mouse outside slider				// trace("mouseup outside");				deactivateSlider();			}			this.stage.removeEventListener(MouseEvent.MOUSE_UP, mouseUpHandler);			this.stage.addEventListener(MouseEvent.MOUSE_MOVE, mouseMoveHandler);		}		//		function mouseMoveHandler(aEvent:MouseEvent):void {			if (!this.visible && !_activeIfInvisible) {				return;			}			if (_sliderActive) {				updateSlider(_sliderClip.mouseX);			}		}		function releaseOutsideHandler(aEvent:MouseEvent):void {					}		//		// ===== OTHER FUNCTIONS ===== //		//		private function activateSlider() {			_sliderActive = true;		}		//		private function deactivateSlider() {			_sliderActive = false;		}		// if slider is activated, moves the slider handle, updates the value, and sendsEvent		private function updateSlider(aXpos:Number, aDontTriggerEvent:Boolean = false) {			//	Util.debug("Slider.UpdateSlider()", aXpos);			// note all x values are relative to _sliderClip			var newVal = calculateValue(aXpos);			// position the handle			var handleX = aXpos; // based on the regpoint on handle which will vary per image						// constrain handle's regpoint to track width			handleX = Math.min(handleX, _trackBounds.right);			handleX = Math.max(handleX, _trackBounds.x);							_sliderValue = newVal;			_sliderClip.handle_mc.x = handleX;			if (!aDontTriggerEvent) {				dispatchEvent(new SliderEvent(SliderEvent.SLIDER_CHANGE, _sliderValue));			}		}		// calulates the slider value as the handle position relative to the track as a percentage		// if the _valueRange parameter is specified, this value is scaled to appropriate value within that range		private function calculateValue(aHandleX:Number) {			// get the unscaled value of handle pos on slider			var val = Mathd.scaleValue(aHandleX, _trackBounds.x, _trackBounds.right, 0, 1, true);						// scale value to specified value ranges			if (_valueRange != null) {				val = Mathd.scaleValue(val, 0, 1, _valueRange.min, _valueRange.max, true);			}						// test for snapping to increments			if (!isNaN(_increment) && _increment >= 1) {				// get the two possible values 				// account for non-zero min values				var lowVal = (int(val/_increment) * _increment) + _valueRange.min;				// constrain this to the slider's min				lowVal = Math.max(lowVal, _valueRange.min);				// constrain this to the slider's max				var hiVal = Math.min(lowVal + _increment, _valueRange.max);				// determine which one is closest to the handle pos				var diffMax = Math.abs(val - hiVal);				var diffMin = Math.abs(val - lowVal);				if (diffMax <= diffMin) {					val = hiVal;				}else {					val = lowVal;				}				// Logger.getLog().debug("slider.UpdateSlider()","increment=" + _increment, "lowVal=" + lowVal, "hiVal=" + hiVal, "newVal="+ val); 			} 						return val;		}		//		// ===== PUBLIC FUNCTIONS ===== //		//		public function setValue(aValue:Number, aDontTriggerEvent:Boolean = false) {			Logger.getLog().debug("slider.setValue()", aValue, _valueRange.min, _valueRange.max, _trackBounds.x, _trackBounds.right);			// determine the new the handle pos and then call updateSlider to take care of moving it, calculating the value, and sending the event			// note the final value is contstrained to be within _valueRange min and max			var newX = Mathd.scaleValue(aValue, _valueRange.min, _valueRange.max, _trackBounds.x, _trackBounds.right, true);			// var newX = Mathd.scaleValue(aValue, 0, 1, _trackBounds.x, _trackBounds.right, true);			updateSlider(newX, true);			updateSlider(newX, aDontTriggerEvent);		}				public function getValue() {			return _sliderValue;		}				// assigns a valueRange to this slider. This range will be used to calculate value instead of the original percentage value calculation		public function setValueRange(aValueRange:Object) {			_valueRange = aValueRange;		}		//		public function setActiveIfInvisible(aState:Boolean) {			_activeIfInvisible = aState;		}		// 		public function hide() {			_sliderClip.visible = false;		}		public function show() {			_sliderClip.visible = true;		}				// returns the rect of the handle relative to the specified target coordinate space.		public function getHandleRect(aTargetCoordSpace) {			return _sliderClip.handle_mc.getBounds(aTargetCoordSpace);		}		// // not sure if this should be public...		// // would we ever want to make it send an event from the outside?		// public function sendEvent(aEventName:String) {		// 	//		Util.debug("Slider.sendEvent()", aEventName, _sliderClip);		// 	var eventObj = {type:aEventName, target:this};		// 	switch (aEventName) {		// 	case "sliderInit" :		// 		break;		// 	case "sliderChange" :		// 		// add the only additional custom property		// 		eventObj.sliderValue = _sliderValue;		// 		break;		// 	}		// 	dispatchEvent(eventObj);		// }			// end class	}} // end package